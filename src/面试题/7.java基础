String、StringBuffer、StringBuilder 区别    https://blog.csdn.net/yin767833376/article/details/54317887
    1、 String、StringBuffer、StringBuilder都是被final修饰的，是不能够被继承改写的。
    2、 String在实例化之后，其内存空间的内容大小是不能够被修改的；而StringBuffer是一个线程安全的可变字符序列，
        在实例化之后可以动态的修改堆内存中的内容，所以内存长度和大小是可变的；StringBuilder实例化之后内存大小长度也是可变的，
        不 同之处在于StringBuilder不是线程同步，因此操作起来必然比StringBuffer更加高效
              而StringBuffer使用时，只会开辟一块内存空间，可以使用append添加delete等操作内容。
              String 每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。
              而如果是使用   StringBuffer/StringBuilder 类则结果就不一样了，
              每次结果都会对 StringBuffer/StringBuilder 对象本身进行操作，而不是生成 新的对象，再改变对象引用。
              因而在对一个字符串循环赋值时，最好使用StringBuffer（线程安全）或StringBuilder，这样可以节约内存，提高性能，切记。




线程安全的可变字符序列。 字符串缓冲区类似于String ，但是可以修改。 它在任何时间点都包含一些特定的字符序列，但是可以通过某些方法调用来更改序列的长度和内容。
字符串缓冲区可安全用于多个线程。 这些方法在必要时进行同步，以使任何特定实例上的所有操作都表现为好像以某种串行顺序发生，该顺序与所涉及的每个单独线程进行的方法调用的顺序一致。
StringBuffer的主要操作是append和insert方法，它们会被重载以接受任何类型的数据。
 每个有效地将给定的基准转换为字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。
 append方法始终将这些字符添加到缓冲区的末尾。 insert方法在指定点添加字符。
例如，如果z指向当前内容为"start"的字符串缓冲区对象，则调用z.append("le")将导致字符串缓冲区包含"startle" z.insert(4, "le") "startle" ，
而z.insert(4, "le")会更改字符串缓冲区以包含"starlet" 。
通常，如果sb引用StringBuffer的实例，则sb.append(x)与sb.insert(sb.length(), x)具有相同的效果。
每当发生涉及源序列的操作（例如从源序列追加或插入）时，此类仅在执行操作的字符串缓冲区上同步，而不在源上同步。
 请注意，虽然StringBuffer被设计为可以安全地从多个线程中并发使用，但如果传递了构造函数或append或insert操作的源序列在线程之间共享，
 则调用代码必须确保该操作具有一致且不变的视图操作期间源序列的序列号。 这可以通过调用方在操作调用期间保持锁定，使用不可变的源序列或不跨线程共享源序列来满足。
每个字符串缓冲区都有一个容量。 只要字符串缓冲区中包含的字符序列的长度不超过容量，就不必分配新的内部缓冲区数组。 如果内部缓冲区溢出，则会自动变大。
除非另有说明，否则将null参数传递给此类中的构造函数或方法将导致引发NullPointerException 。
从JDK 5版本开始，该类已经添加了一个等效类，该等效类设计用于单个线程StringBuilder 。
 通常应优先使用StringBuilder类，因为它支持所有相同的操作，但是它更快，因为它不执行任何同步，因此它优先于该类。






 String类表示字符串。 Java程序中的所有字符串文字（例如"abc" ）都作为此类的实例实现。
 字符串是常量； 它们的值在创建后无法更改。 字符串缓冲区支持可变字符串。 由于String对象是不可变的，因此可以共享它们。 例如：
        String str = "abc";

 等效于：
        char data[] = {'a', 'b', 'c'};
        String str = new String(data);

 以下是一些有关如何使用字符串的示例：
        System.out.println("abc");
        String cde = "cde";
        System.out.println("abc" + cde);
        String c = "abc".substring(2,3);
        String d = cde.substring(1, 2);

 String类包含一些方法，这些方法可以检查序列中的各个字符，比较字符串，搜索字符串，提取子字符串以及创建字符串的副本，并将所有字符均转换为大写或小写。
  大小写映射基于Character类指定的Unicode标准版本。
 Java语言为字符串连接运算符（+）以及将其他对象转换为字符串提供了特殊的支持。
 字符串连接是通过StringBuilder （或StringBuffer ）类及其append方法实现的。
  字符串转换是通过toString方法实现的，该方法由Object定义并由Java中的所有类继承。
  有关字符串连接和转换的其他信息，请参见Java语言规范，Gosling，Joy和Steele。
 除非另有说明，否则将null参数传递给此类中的构造函数或方法将导致引发NullPointerException 。
 String表示采用UTF-16格式的字符串，其中补充字符由代理对表示（有关更多信息，请参见Character类中的Unicode字符表示部分）。
  索引值指的是char代码单位，因此，补充字符在String使用两个位置。
 除了用于处理Unicode代码单元（即， char值）的方法外， String类还提供用于处理Unicode代码点（即，字符）的方法。






 基于哈希表的Map接口的实现。 此实现提供所有可选的映射操作，并允许空值和空键。
 （ HashMap类与Hashtable大致等效，不同之处在于它是不同步的，并且允许为null。）此类不保证映射的顺序。
  特别是，它不能保证顺序会随着时间的推移保持恒定。
 该实现为基本操作（ get和put ）提供了恒定时间的性能，假设哈希函数将元素正确地分散在存储桶中。
  集合视图上的迭代所需的时间与HashMap实例的“容量”（存储桶数）及其大小（键-值映射数）成正比。
   因此，如果迭代性能很重要，则不要将初始容量设置得过高（或负载因子过低），这一点非常重要。
 HashMap的实例具有两个影响其性能的参数：初始容量和负载因子。 容量是哈希表中存储桶的数量，
 初始容量只是创建哈希表时的容量。 负载因子是散列表的容量自动增加之前允许其填充的完整程度的度量。
  当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希（即，内部数据结构将被重建），
  因此哈希表的存储桶数约为两倍。
 通常，默认负载因子（.75）在时间和空间成本之间提供了一个很好的折衷方案。
 较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到了体现，包括get和put ）。
  设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以最大程度地减少重新哈希操作的数量。
   如果初始容量大于最大条目数除以负载因子，则将不会进行任何哈希操作。
 如果将许多映射存储在HashMap实例中，则创建具有足够大容量的映射将比让其根据需要增长表的自动重新哈希处理更有效地存储映射。
  请注意，使用具有相同hashCode()许多键是降低任何哈希表性能的肯定方法。 为了改善影响，当键为Comparable ，
  此类可以使用键之间的比较顺序来帮助打破平局。
 请注意，此实现未同步。 如果多个线程同时访问一个哈希映射，并且至少有一个线程在结构上修改该映射，则必须在外部进行同步。
 （结构修改是添加或删除一个或多个映射的任何操作；仅更改与实例已经包含的键相关联的值不是结构修改。）
 通常通过在自然封装了地图的某个对象上进行同步来完成此操作。 。 如果不存在这样的对象，
 则应使用Collections.synchronizedMap方法“包装”地图。 最好在创建时完成此操作，以防止意外不同步地访问地图：
      Map m = Collections.synchronizedMap(new HashMap(...));
 由此类的所有“集合视图方法”返回的迭代器都是快速失败的：如果在创建迭代器之后的任何时间以任何方式对地图进行结构修改，
 则除了通过迭代器自己的remove方法之外，迭代器都会抛出ConcurrentModificationException 。 因此，面对并发修改，
 迭代器会快速干净地失败，而不会在未来的不确定时间内冒任意，不确定的行为的风险。
 请注意，迭代器的快速失败行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。
  快速失败的迭代器会尽最大努力抛出ConcurrentModificationException 。
   因此，编写依赖于此异常的程序的正确性是错误的：迭代器的快速失败行为应仅用于检测错误。
 此类是Java Collections Framework的成员。
























